
# FPGA License Plate Recognition System

License plate recognition (LPR) is a crucial technology in modern automated vehicle identification systems, widely used in parking management, toll collection, and traffic monitoring. This project is interesting because it leverages FPGA technology for real-time processing, ensuring high-speed and efficient performance. The motivation behind this project is to create a robust and fast system that can be deployed in security-sensitive environments, such as gated communities and restricted areas, to enhance access control mechanisms.


for more infomation, please read our final project report under document
## Block Diagram

![App Screenshot](https://github.com/ECE532-Group-29/FPGA-License-Plate-Recognition-System/blob/main/documentation/image/diagram.png)


The block diagram above illustrates the complete architecture of our FPGA-based Automatic License Plate Recognition (LPR) system. The system begins with image capture from an OV7670 VGA camera, feeding data into the FPGA through a VGA input interface. The captured image is stored in RAM_0 (input buffer) and then processed through a custom image processing pipeline, which includes grayscale conversion and contrast enhancement. The output is sent both to the VGA output for visualization and to the character segmentation module, which isolates individual characters from the license plate. These segmented characters are passed to the rescaling module to resize them to 56x56 pixels, with the output stored in RAM_1. The CNN accelerator, which comprises custom RTL modules such as padding, convolution, max pooling, and a dense layer, reads from RAM_1 and accesses weights and intermediate data stored in RAM_2. The recognized character result is displayed via a seven-segment output. All processing and recognition modules are custom IP, while the VGA input/output and RAM components are adapted from external IP sources. This architecture demonstrates a fully hardware-accelerated, real-time LPR pipeline implemented on FPGA.


## Data Flow Diagram

![App Screenshot](https://github.com/ECE532-Group-29/FPGA-License-Plate-Recognition-System/blob/main/documentation/image/data_flow.png)

The control flow of the License Plate Recognition System is centered around real-time interaction and modular processing. The process begins with the user pressing a hardware push button (BTNR) to trigger image capture from the OV7670 VGA camera. 
The image is written into on-chip BRAM and immediately displayed on a VGA monitor via the VGA_Top module. Users have the option to apply preprocessing filters—such as grayscale, contrast enhancement, and color inversion—by toggling switches (SW1 to SW3). 
Once an image is captured, the center button (BTNC) initiates the segmentation process, extracting and rescaling each character to a fixed 56×56 pixel size. These segmented characters are fed sequentially into the RTL-implemented CNN accelerator, which processes the image in a pipelined manner. 
The CNN predicts the top three possible characters, and the results are displayed using the on-board seven-segment display. A timing controller synchronizes this entire data flow, tracking the current character index and managing reset and done signals for smooth operation. By toggling an additional switch, users can cycle through the CNN’s top-3 predictions for each character, enhancing observability and testing. This interactive control loop enables real-time image recognition while also supporting debugging and step-by-step observation of the processing pipeline.

## Before loading the project: 

1.All the weights and bias used in CNN model of this project is generated using an online source python based script located under simulation folder 

2.Matlab_cnn is a matlab version of the same CNN process we implemented using verilog. Using it to check the intermediate result of each layers. 

3.Generate_image.mlx under simulation/seg_mem_integration/seg_mem_integration.sim/sim_1/behav/xsim/ is a matlab script that convert the mem files generated by running vivado simulation into images, for debug purpose. 

4.Update the constraints file in order to match your own board. 

5.All the control switches and buttons can be found in Demo video or eaxming constraints file:

SW1 : enable gray mode   
SW2: enable inversion gray mode  
SW3: increase contrasting   
SW4: turn on 7 segment display   
SW5: choose between whole license plate mode or sigle character mode.   

BTNU: reset   
BTNL: initial camera   
BTNR: Capture lmage  
BTNC: SegmentationStart   


## Srouce Structure

│   src_structure.md   
│   src_structure.txt   
│   
├───constrs_1  
│&emsp;&emsp;&emsp;   └───imports  
│&emsp;&emsp;&emsp;       └───OV7670-camera-main  
│&emsp;&emsp;&emsp;               Nexys-A7-100T-Master.xdc  
│                 
├───sim_1  
│&emsp;&emsp;&emsp;   ├───imports  
│&emsp;&emsp;&emsp;   │   └───cam_0  
│&emsp;&emsp;&emsp;   │           tb_top_behav.wcfg  
│&emsp;&emsp;&emsp;   │                 
│&emsp;&emsp;&emsp;   └───new  
│&emsp;&emsp;&emsp;           test_7_seg.v  
│           
└───sources_1  
    │&emsp;&emsp;&emsp;verilog_structure.txt  
    │   
    ├───imports  
    │&emsp;&emsp;&emsp;   ├───cam_0  
    │&emsp;&emsp;&emsp;   │       archive_project_summary.txt  
    │&emsp;&emsp;&emsp;   │       
    │&emsp;&emsp;&emsp;   └───rtl  
    │&emsp;&emsp;&emsp;           cam_capture.v  
    │&emsp;&emsp;&emsp;           cam_config.v  
    │&emsp;&emsp;&emsp;           cam_init.v  
    │&emsp;&emsp;&emsp;           cam_rom.v  
    │&emsp;&emsp;&emsp;           cam_top.v  
    │&emsp;&emsp;&emsp;           debounce.v  
    │&emsp;&emsp;&emsp;           mem_bram.v  
    │&emsp;&emsp;&emsp;           sccb_master.v  
    │&emsp;&emsp;&emsp;           top.v  
    │&emsp;&emsp;&emsp;           vga_driver.v  
    │&emsp;&emsp;&emsp;           vga_top.v  
    │           
    ├───ip  
    │   &emsp;└───clk_wiz_0  
    │      &emsp; │   clk_wiz_0.dcp  
    │     &emsp;  │   clk_wiz_0.v  
    │      &emsp; │   clk_wiz_0.veo  
    │      &emsp; │   clk_wiz_0.xci  
    │     &emsp;  │   clk_wiz_0.xdc  
    │      &emsp; │   clk_wiz_0.xml  
    │      &emsp; │   clk_wiz_0_board.xdc  
    │      &emsp; │   clk_wiz_0_clk_wiz.v  
    │     &emsp;  │   clk_wiz_0_ooc.xdc  
    │   &emsp;    │   clk_wiz_0_sim_netlist.v  
    │     &emsp;  │   clk_wiz_0_sim_netlist.vhdl  
    │     &emsp;  │   clk_wiz_0_stub.v  
    │   &emsp;    │   clk_wiz_0_stub.vhdl  
    │    &emsp;   │   mmcm_pll_drp_func_7s_mmcm.vh  
    │    &emsp;   │   mmcm_pll_drp_func_7s_pll.vh  
    │    &emsp;   │   mmcm_pll_drp_func_us_mmcm.vh  
    │    &emsp;   │   mmcm_pll_drp_func_us_pll.vh  
    │    &emsp;   │   mmcm_pll_drp_func_us_plus_mmcm.vh  
    │   &emsp;    │   mmcm_pll_drp_func_us_plus_pll.vh  
    │   &emsp;    │   
    │  &emsp;     └───doc  
    │               &emsp;&emsp;&emsp;clk_wiz_v6_0_changelog.txt  
    │               
    └───new  
&emsp;&emsp;&emsp;            cnn_interface.v  
&emsp;&emsp;&emsp;                       CNN_pixel.sv  
&emsp;&emsp;&emsp;            custom_clk_gen.v  
&emsp;&emsp;&emsp;            data_flow_loop_control.v  
&emsp;&emsp;&emsp;            dense_layer_1.sv  
&emsp;&emsp;&emsp;            dense_layer_2.sv  
&emsp;&emsp;&emsp;            grayscale.v  
&emsp;&emsp;&emsp;            maxpooling.v  
&emsp;&emsp;&emsp;            mem_control.v  
&emsp;&emsp;&emsp;            padding_zeros.v  
&emsp;&emsp;&emsp;            rescaling.v  
&emsp;&emsp;&emsp;            segmentation.v  
&emsp;&emsp;&emsp;            seven_seg_display_interface.v  
&emsp;&emsp;&emsp;            size_trim.v  

The above tree shows the locations of our project's primary files and folders.  Only the important and custom folders are discussed here.
